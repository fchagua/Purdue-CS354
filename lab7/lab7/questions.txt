1. I changed pstate from PIPE_FREE to PIPE_OPEN for the given pipe
2. When the program finds an empty pipe device, it will return the pipe's pdevid since pipe_init assigned the device's dvnum to the pipe's pdevid
3. After startup, the value of PIPE0 is returned since it is the first empty pipe device among the 10 pipe devices.
4. Npip represents the number of pseudo pipe devices there are. It is defined in conf.h which is generated by Configuration. It is inserted when Configuration configures the program.
5. It checks the state of the pipe device to see it is free of EOF because they do different tasks. Also, if the pipe device is not open then it should not be receiving more bytes and waiting for bytes to be input will put it on hold forever.
6. It check the state of the pipe device after the semaphore wait because there could have been a state change. There is a sitation where pipe_close is called while pipe_getc is waiting.
7. To test if the calling process is blocked, it is possible to check if the process checks the process state before the wait and before the signal to see if the process changes from current to waiting.
8. I would have to change the Configuration file to add the pipe pseudo devices. This would also reconfigure Npip which adjusts to the new number of pipes.
9. To leave the old code unchanged and build Xinu to call the new pipe_close, it is possible to change the Makefile so that pipe_close can call pipe_opt_close instead.

